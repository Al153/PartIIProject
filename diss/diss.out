\BOOKMARK [0][-]{chapter.1}{Introduction}{}% 1
\BOOKMARK [0][-]{chapter.2}{Preparation}{}% 2
\BOOKMARK [1][-]{section*.8}{The Scala Programming Language}{chapter.2}% 3
\BOOKMARK [1][-]{section*.9}{Definition of Type-Safety}{chapter.2}% 4
\BOOKMARK [1][-]{section*.10}{Existing Graph Databases}{chapter.2}% 5
\BOOKMARK [2][-]{section*.11}{Classes of Database}{section*.10}% 6
\BOOKMARK [2][-]{section*.12}{Schema}{section*.10}% 7
\BOOKMARK [2][-]{section*.13}{Mutability}{section*.10}% 8
\BOOKMARK [2][-]{section*.14}{Query Languages}{section*.10}% 9
\BOOKMARK [1][-]{section*.15}{Immutability}{chapter.2}% 10
\BOOKMARK [1][-]{section*.16}{Query Language}{chapter.2}% 11
\BOOKMARK [2][-]{section*.17}{Domain Specific Language Syntax}{section*.16}% 12
\BOOKMARK [2][-]{section*.18}{Semantic Definitions}{section*.16}% 13
\BOOKMARK [2][-]{section*.27}{Typing}{section*.16}% 14
\BOOKMARK [2][-]{section*.28}{Semantics}{section*.16}% 15
\BOOKMARK [2][-]{section*.31}{Commands}{section*.16}% 16
\BOOKMARK [2][-]{section*.32}{Summary}{section*.16}% 17
\BOOKMARK [1][-]{section*.33}{Starting Point}{chapter.2}% 18
\BOOKMARK [1][-]{section*.34}{Software Engineering}{chapter.2}% 19
\BOOKMARK [2][-]{section*.35}{Requirements Analysis}{section*.34}% 20
\BOOKMARK [1][-]{section*.36}{Scala Techniques}{chapter.2}% 21
\BOOKMARK [2][-]{section*.37}{Type-Enrichment}{section*.36}% 22
\BOOKMARK [2][-]{section*.38}{Implicit Parameters}{section*.36}% 23
\BOOKMARK [2][-]{section*.39}{Typeclass Pattern}{section*.36}% 24
\BOOKMARK [0][-]{chapter.3}{Implementation}{}% 25
\BOOKMARK [1][-]{section*.40}{Note on Purity and Concurrency}{chapter.3}% 26
\BOOKMARK [1][-]{section*.41}{Functional Programming Techniques}{chapter.3}% 27
\BOOKMARK [2][-]{section*.42}{Monadic Compilation}{section*.41}% 28
\BOOKMARK [2][-]{section*.43}{Constrained Future Monad}{section*.41}% 29
\BOOKMARK [2][-]{section*.44}{Operation Monad}{section*.41}% 30
\BOOKMARK [2][-]{section*.45}{Local and Global State}{section*.41}% 31
\BOOKMARK [1][-]{section*.46}{Schema Implementation}{chapter.3}% 32
\BOOKMARK [2][-]{section*.47}{Schema Hierarchy}{section*.46}% 33
\BOOKMARK [2][-]{section*.48}{DBObjects}{section*.46}% 34
\BOOKMARK [2][-]{section*.49}{Unerasure}{section*.46}% 35
\BOOKMARK [2][-]{section*.50}{Relations}{section*.46}% 36
\BOOKMARK [2][-]{section*.51}{SchemaDescription}{section*.46}% 37
\BOOKMARK [2][-]{section*.52}{Findables}{section*.46}% 38
\BOOKMARK [1][-]{section*.53}{Query ADT}{chapter.3}% 39
\BOOKMARK [1][-]{section*.54}{Commands}{chapter.3}% 40
\BOOKMARK [1][-]{section*.55}{DSL}{chapter.3}% 41
\BOOKMARK [1][-]{section*.56}{Common Generic Algorithms}{chapter.3}% 42
\BOOKMARK [2][-]{section*.57}{Simple Traversal}{section*.56}% 43
\BOOKMARK [2][-]{section*.61}{Full traversal}{section*.56}% 44
\BOOKMARK [2][-]{section*.65}{Pathfinding}{section*.56}% 45
\BOOKMARK [2][-]{section*.66}{Joins}{section*.56}% 46
\BOOKMARK [1][-]{section*.67}{Views and Commits}{chapter.3}% 47
\BOOKMARK [1][-]{section*.68}{Memory Back-end}{chapter.3}% 48
\BOOKMARK [2][-]{section*.69}{Table Structure}{section*.68}% 49
\BOOKMARK [2][-]{section*.70}{Reads}{section*.68}% 50
\BOOKMARK [2][-]{section*.71}{Left Optimisation}{section*.68}% 51
\BOOKMARK [2][-]{section*.72}{Writes}{section*.68}% 52
\BOOKMARK [2][-]{section*.73}{Storage}{section*.68}% 53
\BOOKMARK [2][-]{section*.74}{Mutability}{section*.68}% 54
\BOOKMARK [2][-]{section*.75}{Pathfinding and fixed point traversal}{section*.68}% 55
\BOOKMARK [1][-]{section*.76}{PostgreSQL back-end}{chapter.3}% 56
\BOOKMARK [2][-]{section*.77}{Table Structure}{section*.76}% 57
\BOOKMARK [2][-]{section*.80}{Query Structure}{section*.76}% 58
\BOOKMARK [2][-]{section*.81}{Monadic Compilation}{section*.76}% 59
\BOOKMARK [2][-]{section*.82}{Writes}{section*.76}% 60
\BOOKMARK [2][-]{section*.83}{Mutability}{section*.76}% 61
\BOOKMARK [2][-]{section*.84}{Pathfinding and Fixed Point Traversal}{section*.76}% 62
\BOOKMARK [2][-]{section*.85}{Object Storage}{section*.76}% 63
\BOOKMARK [1][-]{section*.86}{LMDB Back-ends}{chapter.3}% 64
\BOOKMARK [2][-]{section*.87}{Common}{section*.86}% 65
\BOOKMARK [2][-]{section*.95}{Original LMDB Implementation}{section*.86}% 66
\BOOKMARK [2][-]{section*.96}{Batched}{section*.86}% 67
\BOOKMARK [2][-]{section*.100}{Common Sub-Expression Elimination}{section*.86}% 68
\BOOKMARK [2][-]{section*.104}{Complex Common Sub-Expression Elimination}{section*.86}% 69
\BOOKMARK [1][-]{section*.108}{Summary}{chapter.3}% 70
\BOOKMARK [0][-]{chapter.4}{Evaluation}{}% 71
\BOOKMARK [1][-]{section*.109}{Unit Tests}{chapter.4}% 72
\BOOKMARK [1][-]{section*.110}{Performance Tests}{chapter.4}% 73
\BOOKMARK [2][-]{section*.111}{Hardware}{section*.110}% 74
\BOOKMARK [2][-]{section*.112}{Datasets}{section*.110}% 75
\BOOKMARK [2][-]{section*.119}{Test Harness}{section*.110}% 76
\BOOKMARK [2][-]{section*.120}{Results}{section*.110}% 77
\BOOKMARK [0][-]{chapter.5}{Conclusion}{}% 78
\BOOKMARK [1][-]{section*.131}{Successes}{chapter.5}% 79
\BOOKMARK [1][-]{section*.132}{Further extensions}{chapter.5}% 80
\BOOKMARK [1][-]{section*.133}{Lessons learned}{chapter.5}% 81
\BOOKMARK [1][-]{section*.134}{Concluding Thoughts}{chapter.5}% 82
\BOOKMARK [0][-]{section*.134}{Bibliography}{}% 83
\BOOKMARK [0][-]{chapter*.135}{Appendix}{}% 84
\BOOKMARK [0][-]{appendix.A}{The Domain closure\(A, v\)}{}% 85
\BOOKMARK [0][-]{appendix.B}{Correspondence of Operational and Denotational Semantics}{}% 86
\BOOKMARK [0][-]{appendix.C}{Properties of the Join Denotation}{}% 87
\BOOKMARK [1][-]{section*.169}{Join as a monoid operation}{appendix.C}% 88
\BOOKMARK [2][-]{section*.170}{Join is closed on QueryA\(v\)}{section*.169}% 89
\BOOKMARK [2][-]{section*.172}{Lemma: Join is associative on QueryA\(v\)}{section*.169}% 90
\BOOKMARK [2][-]{section*.174}{[[Id_A]]\(v\) As an Identity of Join}{section*.169}% 91
\BOOKMARK [1][-]{section*.176}{Usages of Join as a Monoid}{appendix.C}% 92
\BOOKMARK [1][-]{section*.177}{Joins distribute over Or}{appendix.C}% 93
\BOOKMARK [1][-]{section*.178}{Upto\(n, P\) expressed as Exactly\(n, P'\)}{appendix.C}% 94
\BOOKMARK [1][-]{section*.179}{Joins do not distribute over And}{appendix.C}% 95
\BOOKMARK [0][-]{appendix.D}{Scala Algebraic Data Type Definitions}{}% 96
\BOOKMARK [0][-]{appendix.E}{Denotational Semantics Based Memory Implementation}{}% 97
\BOOKMARK [1][-]{section*.180}{FindPairs}{appendix.E}% 98
\BOOKMARK [1][-]{section*.181}{FindSingle}{appendix.E}% 99
\BOOKMARK [0][-]{appendix.F}{DSL Examples}{}% 100
\BOOKMARK [1][-]{section*.182}{Simple Transitive Queries}{appendix.F}% 101
\BOOKMARK [1][-]{section*.183}{FindSingle queries}{appendix.F}% 102
\BOOKMARK [1][-]{section*.184}{Union and Intersection}{appendix.F}% 103
\BOOKMARK [1][-]{section*.185}{Repetition}{appendix.F}% 104
\BOOKMARK [0][-]{appendix.G}{Example of SchemaObject implementation}{}% 105
\BOOKMARK [0][-]{appendix.H}{Proposal}{}% 106
\BOOKMARK [1][-]{section*.186}{Computer Science Tripos \205 Part II \205 Project Proposal}{appendix.H}% 107
\BOOKMARK [1][-]{section*.187}{A purely functional approach to graph queries on a database}{appendix.H}% 108
\BOOKMARK [2][-]{section*.188}{Introduction}{section*.187}% 109
\BOOKMARK [2][-]{section*.189}{Project Description}{section*.187}% 110
\BOOKMARK [2][-]{section*.190}{Starting point}{section*.187}% 111
\BOOKMARK [2][-]{section*.191}{Resources required}{section*.187}% 112
\BOOKMARK [2][-]{section*.194}{Project Structure}{section*.187}% 113
\BOOKMARK [2][-]{section*.195}{Success Criteria}{section*.187}% 114
\BOOKMARK [2][-]{section*.196}{Extensions}{section*.187}% 115
\BOOKMARK [2][-]{section*.197}{Evaluation}{section*.187}% 116
\BOOKMARK [2][-]{section*.198}{Timetable}{section*.187}% 117
